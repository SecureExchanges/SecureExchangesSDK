using System;
using System.Collections.Generic;
using System.Configuration;
using System.IO;
using System.Reflection;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using SecureExchangesSDK.Helpers;
using SecureExchangesSDK.Models;
using SecureExchangesSDK.Models.Answer;
using SecureExchangesSDK.Models.Args;
using SecureExchangesSDK.Models.Entity;
using SecureExchangesSDK.Models.Transport;
using SecureExchangesSDK.SecureExchanges;

namespace SecureExchangesSamples
{
  [TestClass]
  public class MessageHelperTest
  {
    // You need to purchase licence to use Secure Exchanges
    // You can request a 30 days trial version by register yourself at https://www.secure-exchanges.com/Free-trial-secure-email-sending.aspx

    private const string _globalPassword = "mypassword";

    /// <summary>
    /// Put your serial number
    /// </summary>
    private Guid TestSerialNumber = new Guid(ConfigurationManager.AppSettings["Serial"].ToString());
    /// <summary>
    /// Put your api number
    /// </summary>
    private Guid TestAPIUser = new Guid(ConfigurationManager.AppSettings["APIUser"].ToString());
    /// <summary>
    /// put your API psw
    /// </summary>
    private Guid TestAPIPsw = new Guid(ConfigurationManager.AppSettings["APIPsw"].ToString());
    private Uri EndPointURI = new Uri("https://www.secure-exchanges.com/_api/0217/0217.asmx");

    private string RootPath
    {
      get
      {
        return Assembly.GetExecutingAssembly().Location.Replace(@"\bin\Debug\CodeSample.dll", "");
      }
    }
    /// <summary>
    /// This is an example how to send message to multiple recipient.
    /// </summary>
    [TestMethod]
    public MultiRecipientAnswer MultiSendEmailWithLocalFiles()
    {
      // Create a files list path : physical path
      List<string> files = new List<string>();
      // Get the project path


      // Append the file to send and encrypt
      files.Add(Path.Combine(RootPath, "Files", "logo-full.png"));

      // Fill this list if your have memory file to encrypt and send has attachment
      List<FileArgs> filesArgs = null;

      // Configure the message body, and the subject
      string HTMLBody = "<strong>This is my html message</strong>";
      string EmailSubject = "This is my public subject";

      // Create a list of recipient. Phone number could be filled to received SMS
      // WARNING : the SendMethodEnum must be set to msgEmailCodeSms to received an email with a sms code to open it
      List<RecipientInfo> recipients = new List<RecipientInfo>();

      // Please enter the email and Phone number here
      recipients.Add(new RecipientInfo() { Email = "support@secure-exchanges.com", Phone = "" });

      // That is a password protection level
      string messagePassword = _globalPassword;

      // Define the sending mode
      // OnlyEmail - no additional protection, only a email need to provide the email in the recipient
      // msgSMSOnly - no additional protection, only a sms       need to provide the phone number in the recipient
      // msgEmailCodeSms - send a email with a 6 digit autogenerated code by sms, need to provide the phone number and email in each in the recipient
      // msgSMSCodeEmail  - send a SMS with a 6 digit autogenerated code by email, need to provide the phone number and email in each in the recipient
      SendMethodEnum sendingMode = SendMethodEnum.onlyEmail;

      // If set to true, will return the HTML message obfuscated, and protected, you need to send it by email
      // If set to false, Secure Exchanges will send the message for you
      bool sendMessageByMyself = true;

      // Received the notify by email, when the message will be read
      bool getNotify = true;
      // The culture of the message. Currently support "fr-CA" and "en-CA"
      string culture = "fr-CA";
      //Create the message args
      var args = new MutliRecipientArgs(
         EndPointURI,
         TestSerialNumber,
         TestAPIUser,
         TestAPIPsw,
         recipients,
         HTMLBody,
         EmailSubject,
         messagePassword,
         filesArgs,
         sendingMode,
         sendMessageByMyself,
         true,
         getNotify, culture, 1, 5)
      { FilesPath = files };
      // Call the multicecipient method 
      MultiRecipientAnswer answer = MessageHelper.MultiRecipientMessage(args);
      // if the status is set to 200 the call was made successfully. See in answer.Data if the status is not 200
      if (answer.Status == 200)
      {
        foreach (var a in answer.RecipientsAnswer)
        {
          // Here use a.Answer.HtmlMsg to send your email with your SMTP server
          // a.Answer.Guid -- this is the reference of a messageid. Keep it in your système to retreived log about this message


        }
      }
      else
      {
        throw new Exception($"Erreur {answer.Status}");
      }
      return answer;
    }

    [TestMethod]
    public void CreateEnvelop()
    {
      GetEnveloppeResponse response = SecureExchangesSDK.Helpers.MessageHelper.GetEnveloppe(new
       SecureExchangesSDK.Models.Args.GetEnveloppeArgs(EndPointURI, TestSerialNumber, TestAPIUser, TestAPIPsw, "Reply", "email1;email2;", "fr-CA")
      {
        // If you get a callback API activated set it to true, if not set it to no
        ReplyToAPI = false,
        // if reply api is activated
        CallBackParameters = "Your callback parameter, xml, json what you want"
      });

      if (response.StatusCode == 200)
      {
        // success envelop created
        // Send this url by email, this is your envelop email
        // response.Url;
      }
    }

    /// <summary>
    /// This method, is to get the logs about a specific message send by the user. 
    /// Get the informations about the read, the download etc..
    /// MessageId came from a.Answer.Guid of the send message
    /// </summary>
    /// <param name="messageId"></param>
    [TestMethod]
    public void GetLogsOfSpecificMessage(Guid messageId)
    {
      LogsHelper.GetLog(new GetLogArgs(EndPointURI, TestSerialNumber, TestAPIUser, TestAPIPsw, messageId));
    }


    /// <summary>
    /// That case is not real, but let you see how the SDK are able to send a secure message, then read the same message.
    /// </summary>
    /// <param name="link"></param>
    /// <param name="password"></param>
    /// <param name="digit"></param>
    [TestMethod]
    public void SendAndReadMessage()
    {
      var answer = MultiSendEmailWithLocalFiles();
      if (answer.Status == 200)
      {
        foreach (var messageAnswer in answer.RecipientsAnswer)
        {
          ReadSecureExchangesMessage(messageAnswer.Answer.URL, _globalPassword, null);
        }
      }
    }



    public void ReadSecureExchangesMessage(string link, string password, string digit)
    {
      SecureExchangesMessage msg = MessageHelper.GetSecureExchangesMessageFromLink(link);

      GetMessageResponse messageResponse = SecureExchangesSDK.Helpers.MessageHelper.GetMessage(new SecureExchangesSDK.Models.Args.GetMessageArgs(EndPointURI, TestSerialNumber, TestAPIUser, TestAPIPsw, msg.MessageID, msg.Cpart, msg.Sems, msg.NIv, msg.P2, password, msg.Pit, digit, msg.Sit));
      if (messageResponse != null)
      {
        // this will be the un encrypted message
        string confidentialMessage = messageResponse.Message;
        // that will be the subject
        string subject = messageResponse.Subject;
        // Download the message file
        DownloadMessageFile(messageResponse, Path.Combine(RootPath, "Download"));
      }
    }

    private void DownloadMessageFile(GetMessageResponse response, string downloadPath)
    {

      FileHelper fileHelper = new FileHelper();
      var finalPath = fileHelper.PrepareFileToDownload(response.FilesMetaData, downloadPath);
      fileHelper.DownloadSecureFiles(response.FilesMetaData, downloadPath);
      int fileFinish = 0;
      int totalFile = response.FilesMetaData.Files.Count;
      // The event for a file
      fileHelper.DownloadFinish_event += (file) =>
      {
          // a file is finish
          fileFinish++;
      };
      // all the file are finish
      fileHelper.DownloadsFinish_event += (files) =>
      {
        // files are downloadedFiles
        if (fileFinish != files.Count)
        {
          // an error has occur
        }
        else
        {
          // your files are downloaded and decrypted
        }
      };






    }

    [TestMethod]
    public void IsValidLicence()
    {
      // True
      bool isVAlid = SecureExchangesSDK.Helpers.LicenceHelper.IsLicenceIsValid(new IsLicenceIsValidArgs()
      {
        ApiPassword = TestAPIPsw,
        ApiUser = TestAPIUser,
        Email = ConfigurationManager.AppSettings["LicenceEmail"].ToString(),
        EndPointUri = EndPointURI,
        Serial = TestSerialNumber
      });

    }
  }
}
