using System;
using System.Collections.Generic;
using System.Configuration;
using System.IO;
using System.Reflection;
using CodeSample.Helper;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using SecureExchangesSDK.Helpers;
using SecureExchangesSDK.Models;
using SecureExchangesSDK.Models.Answer;
using SecureExchangesSDK.Models.Args;
using SecureExchangesSDK.Models.Entity;
using SecureExchangesSDK.Models.JSON;
using SecureExchangesSDK.Models.Transport;
using SecureExchangesSDK.SecureExchanges;

namespace SecureExchangesSamples
{
  [TestClass]
  public class MessageHelperTest
  {
    // You need to purchase licence to use Secure Exchanges
    // You can request a 30 days trial version by register yourself at https://www.secure-exchanges.com/Free-trial-secure-email-sending.aspx

    private const string _globalPassword = "mypassword";

    /// <summary>
    /// Put your serial number
    /// </summary>
    private Guid TestSerialNumber = new Guid(ConfigurationManager.AppSettings["Serial"].ToString());
    /// <summary>
    /// Put your api number
    /// </summary>
    private Guid TestAPIUser = new Guid(ConfigurationManager.AppSettings["APIUser"].ToString());
    /// <summary>
    /// put your API psw
    /// </summary>
    private Guid TestAPIPsw = new Guid(ConfigurationManager.AppSettings["APIPsw"].ToString());
    private Uri EndPointURI
    {

      get
      {
        return EndpointHelper.EndPoint;
      }

    }

    private string RootPath
    {
      get
      {
        return Assembly.GetExecutingAssembly().Location.Replace(@"\bin\Debug\CodeSample.dll", "");
      }
    }
    /// <summary>
    /// This is an example how to send message to multiple recipient.
    /// </summary>

    public MultiRecipientAnswer MultiSendEmailWithLocalFiles(bool useFileArgs = false)
    {
      // Create a files list path : physical path
      List<string> files = new List<string>();
      // Get the project path

      if (!useFileArgs)
        // Append the file to send and encrypt
        files.Add(Path.Combine(RootPath, "Files", "logo-full.png"));

      // Fill this list if your have memory file to encrypt and send has attachment
      List<FileArgs> filesArgs = null;

      // If you want to fille the fileargs with binary
      if (useFileArgs)
      {
        string fileName = Path.GetFileName(Path.Combine(RootPath, "Files", "logo-full.png"));
        filesArgs = new List<FileArgs>()
      {
        new FileArgs(File.ReadAllBytes(Path.Combine(RootPath, "Files", "logo-full.png")),fileName,MimeHelper.GetMIMEType(fileName))

      };
      }

      // Configure the message body, and the subject
      string HTMLBody = "<strong>This is my html message</strong>";
      string EmailSubject = "This is my public subject";

      // Create a list of recipient. Phone number could be filled to received SMS
      // WARNING : the SendMethodEnum must be set to msgEmailCodeSms to received an email with a sms code to open it
      List<RecipientInfo> recipients = new List<RecipientInfo>();

      // Please enter the email and Phone number here
      recipients.Add(new RecipientInfo() { Email = "support@secure-exchanges.com", Phone = "" });

      // That is a password protection level
      string messagePassword = _globalPassword;

      // Define the sending mode
      // OnlyEmail - no additional protection, only a email need to provide the email in the recipient
      // msgSMSOnly - no additional protection, only a sms       need to provide the phone number in the recipient
      // msgEmailCodeSms - send a email with a 6 digit autogenerated code by sms, need to provide the phone number and email in each in the recipient
      // msgSMSCodeEmail  - send a SMS with a 6 digit autogenerated code by email, need to provide the phone number and email in each in the recipient
      SendMethodEnum sendingMode = SendMethodEnum.onlyEmail;

      // If set to true, will return the HTML message obfuscated, and protected, you need to send it by email
      // If set to false, Secure Exchanges will send the message for you
      bool sendMessageByMyself = true;

      // Received the notify by email, when the message will be read
      bool getNotify = true;
      // The culture of the message. Currently support "fr-CA" and "en-CA"
      string culture = "fr-CA";
      //Create the message args
      var args = new MutliRecipientArgs(
         EndPointURI,
         TestSerialNumber,
         TestAPIUser,
         TestAPIPsw,
         recipients,
         HTMLBody,
         EmailSubject,
         messagePassword,
         filesArgs,
         sendingMode,
         sendMessageByMyself,
         true,
         getNotify, culture, 1, 5)
      { FilesPath = files };
      // Call the multicecipient method 
      MultiRecipientAnswer answer = MessageHelper.MultiRecipientMessage(args);
      // if the status is set to 200 the call was made successfully. See in answer.Data if the status is not 200
      if (answer.Status == 200)
      {
        foreach (var a in answer.RecipientsAnswer)
        {
          // Here use a.Answer.HtmlMsg to send your email with your SMTP server
          // a.Answer.Guid -- this is the reference of a messageid. Keep it in your système to retreived log about this message


        }
      }
      else
      {
        throw new Exception($"Erreur {answer.Status}");
      }
      return answer;
    }

    [TestMethod]
    public void CreateEnvelop()
    {
      GetEnveloppeResponse response = SecureExchangesSDK.Helpers.MessageHelper.GetEnveloppe(new
       SecureExchangesSDK.Models.Args.GetEnveloppeArgs(EndPointURI, TestSerialNumber, TestAPIUser, TestAPIPsw, "Reply", "email1;email2;", "fr-CA")
      {
        // If you get a callback API activated set it to true, if not set it to no
        ReplyToAPI = false,
        // if reply api is activated
        CallBackParameters = "Your callback parameter, xml, json what you want"
      });

      if (response.StatusCode == 200)
      {
        // success envelop created
        // Send this url by email, this is your envelop email
        // response.Url;
      }
    }

    /// <summary>
    /// This method, is to get the logs about a specific message send by the user. 
    /// Get the informations about the read, the download etc..
    /// MessageId came from a.Answer.Guid of the send message
    /// </summary>
    /// <param name="messageId"></param>
    [TestMethod]
    public void GetLogsOfSpecificMessage(Guid messageId)
    {
      LogsHelper.GetLog(new GetLogArgs(EndPointURI, TestSerialNumber, TestAPIUser, TestAPIPsw, messageId));
    }


    /// <summary>
    /// That case is not real, but let you see how the SDK are able to send a secure message, then read the same message.
    /// </summary>
    /// <param name="link"></param>
    /// <param name="password"></param>
    /// <param name="digit"></param>
    [TestMethod]
    public void SendAndReadMessageWithFilePath()
    {
      var answer = MultiSendEmailWithLocalFiles();
      if (answer.Status == 200)
      {
        foreach (var messageAnswer in answer.RecipientsAnswer)
        {
          ReadSecureExchangesMessage(messageAnswer.Answer.URL, _globalPassword, null);
        }
      }
    }

    /// <summary>
    /// That case is not real, but let you see how the SDK are able to send a secure message, then read the same message.
    /// </summary>
    /// <param name="link"></param>
    /// <param name="password"></param>
    /// <param name="digit"></param>
    [TestMethod]
    public void SendAndReadMessageWithFileArgs()
    {
      // se the value at true, to use the fileargs
      var answer = MultiSendEmailWithLocalFiles(true);
      if (answer.Status == 200)
      {
        foreach (var messageAnswer in answer.RecipientsAnswer)
        {
          ReadSecureExchangesMessage(messageAnswer.Answer.URL, _globalPassword, null);
        }
      }
    }

    /// <summary>
    /// Show how we can send secure file to get signed
    /// </summary>
    [TestMethod]
    public void SendSignFile()
    {
      // Create a list of recipient. Phone number could be filled to received SMS
      // WARNING : the SendMethodEnum must be set to msgEmailCodeSms to received an email with a sms code to open it
      List<RecipientInfo> recipients = new List<RecipientInfo>();
      recipients.Add(new RecipientInfo() { Email = "support@secure-exchanges.com", Phone = "" });
      recipients.Add(new RecipientInfo() { Email = "teams@secure-exchanges.com", Phone = "" });

      // Create a files list path : physical path
      List<string> files = new List<string>();
      // The PDF File that need to be signed
      files.Add(Path.Combine(RootPath, "Files", "model.pdf"));

      /// Load the template associated with that serial number
      var loadTemplateAnswer = SerialHelper.LoadSignsTemplate(new LoadSignsTemplateArgs()
      {
        EndPointUri = EndPointURI,
        Serial = TestSerialNumber,
        ApiUser = TestAPIUser,
        ApiPassword = TestAPIPsw
      });

      // Create a list of SignFilesRequired
      List<SignFilesRequired> signFiles = new List<SignFilesRequired>();

      // Create a dictionnary of recipients info with FileDefinition signatures
      Dictionary<RecipientInfo, List<FileZoneDefinition>> recipientIndex = new Dictionary<RecipientInfo, List<FileZoneDefinition>>();
      // Identify in the list of files, the file need to be signed
      foreach (string f in files)
      {
        // Retreived the SHA512 of file need to be signed
        string SHA512 = CryptoHelper.GetSHA512OfFile(f);
        // Add that checksum to the signFilesRequired list
        signFiles.Add(new SignFilesRequired()
        {
          SHA512 = SHA512
        });
        // Because the name of the zones defined in the template are client 1, client 2, ...
        int clientPos = 1;
        // iterate trhow the recipient to specify the defines zone for the specific file for each recipients
        foreach (var r in recipients)
        {
          // Validate that we found template. If no template exist, the signature will be in freemode
          if (loadTemplateAnswer.Status == 200 && loadTemplateAnswer.Template != null)
          {

            // Find the right Zonefiles definition for that file. We search the template by filename, because we juste saved the template with
            // the file name in the system
            // We could also find the right template by the checksum, but the checksum of the file must be identical of the template item.FileDefinition.UniqueName == SHA512
            var template = loadTemplateAnswer.Template.Find(item => string.Compare(item.Name, Path.GetFileName(f), true) == 0);
            if (template != null)
            {
              // We add to the dictionnary the definition zone for that recipient. client 1 = recipient1, client2 = recipient2 etc ...
              SignHelper.AddFileZoneDefToRecipientIndex(recipientIndex, template.FileDefinition.ZonesDef, SHA512,
                new KeyValuePair<string, RecipientInfo>($"client {clientPos}", r));

            }
          }
          clientPos++;
        }
      }

      // Configure the message body, and the subject
      string HTMLBody = "<strong>Please sign the files</strong>";
      string EmailSubject = "Sign file";
      string psw = "protected";
      // Let you send the mail with your own smtp server
      bool sendWitMyOwnSMPTServer = false;


      //Create the message args
      var args = new MutliRecipientArgs(
          EndPointURI,
         TestSerialNumber,
         TestAPIUser,
         TestAPIPsw,
         recipients,
         HTMLBody,
         EmailSubject,
         psw,
         null,
         SecureExchangesSDK.SecureExchanges.SendMethodEnum.onlyEmail,
         sendWitMyOwnSMPTServer,
         true,
         true, "fr-CA", 1, 5)
      { FilesPath = files };
      // Because we have some file to sign, we add them to the args
      // Notes that you can send files witout signature only to the first recipient, if you have multiple recipient.
      if (signFiles.Count > 0)
      {
        // Set the files to be sign
        args.FileToSign = signFiles;
        // If the owner of the licence need to sign the file, set the value to false.
        // If it's set to false, the licence owner will receive an email when the file will be ready to sign by him
        args.OwnerDontNeedToSign = true;
        // Set the recipient zone definition
        args.SignRecipientsZoneDef = SignHelper.ConvertRecipientIndexToList(recipientIndex);
      }

      // Call the multicecipient method 
      MultiRecipientAnswer answer = MessageHelper.MultiRecipientMessage(args);
      if (answer.Status == 200)
      {
        foreach (var a in answer.RecipientsAnswer)
        {
          // Here use a.Answer.HtmlMsg to send your email with your SMTP server
          // a.Answer.Guid -- this is the reference of a messageid. Keep it in your système to retreived log about this message


        }
      }
      else
      {
        throw new Exception($"Erreur {answer.Status}");
      }
    }


    public void ReadSecureExchangesMessage(string link, string password, string digit)
    {
      SecureExchangesMessage msg = MessageHelper.GetSecureExchangesMessageFromLink(link);

      GetMessageResponse messageResponse = SecureExchangesSDK.Helpers.MessageHelper.GetMessage(new SecureExchangesSDK.Models.Args.GetMessageArgs(EndPointURI, TestSerialNumber, TestAPIUser, TestAPIPsw, msg.MessageID, msg.Cpart, msg.Sems, msg.NIv, msg.P2, password, msg.Pit, digit, msg.Sit));
      if (messageResponse != null)
      {
        // this will be the un encrypted message
        string confidentialMessage = messageResponse.Message;
        // that will be the subject
        string subject = messageResponse.Subject;
        // Download the message file
        DownloadMessageFile(messageResponse, Path.Combine(RootPath, "Download"));
      }
    }

    private void DownloadMessageFile(GetMessageResponse response, string downloadPath)
    {

      FileHelper fileHelper = new FileHelper();
      var finalPath = fileHelper.PrepareFileToDownload(response.FilesMetaData, downloadPath);
      fileHelper.DownloadSecureFiles(response.FilesMetaData, downloadPath);
      int fileFinish = 0;
      int totalFile = response.FilesMetaData.Files.Count;
      // The event for a file
      fileHelper.DownloadFinish_event += (file) =>
      {
        // a file is finish
        fileFinish++;
      };
      // all the file are finish
      fileHelper.DownloadsFinish_event += (files) =>
      {
        // files are downloadedFiles
        if (fileFinish != files.Count)
        {
          // an error has occur
        }
        else
        {
          // your files are downloaded and decrypted
        }
      };






    }

    [TestMethod]
    public void IsValidLicence()
    {
      // True
      bool isVAlid = SecureExchangesSDK.Helpers.LicenceHelper.IsLicenceIsValid(new IsLicenceIsValidArgs()
      {
        ApiPassword = TestAPIPsw,
        ApiUser = TestAPIUser,
        Email = ConfigurationManager.AppSettings["LicenceEmail"].ToString(),
        EndPointUri = EndPointURI,
        Serial = TestSerialNumber
      });

    }
  }
}
